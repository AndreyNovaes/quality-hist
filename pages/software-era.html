<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta name="description" content="A Era do Software: o nascimento da disciplina de testes">
    <title>Era do Software - A Jornada da Qualidade</title>
    <link rel="stylesheet" href="../css/styles.css">
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&family=Playfair+Display:wght@600;700&display=swap" rel="stylesheet">
</head>
<body>
    <!-- Header e Navega√ß√£o -->
    <header class="main-header">
        <div class="container">
            <nav class="nav-container">
                <div class="logo">
                    ‚öñÔ∏è A Jornada da Qualidade
                </div>
                <nav class="main-nav">
                    <ul>
                        <li><a href="../index.html">In√≠cio</a></li>
                        <li><a href="ancient-roots.html">Ra√≠zes Antigas</a></li>
                        <li><a href="industrial-revolution.html">Rev. Industrial</a></li>
                        <li><a href="software-era.html">Era do Software</a></li>
                        <li><a href="modern-future.html">Futuro</a></li>
                        <li><a href="timeline.html">Linha do Tempo</a></li>
                        <li><a href="pioneers.html">Pioneiros</a></li>
                    </ul>
                </nav>
            </nav>
        </div>
    </header>

    <!-- Page Header -->
    <section class="page-header">
        <div class="container">
            <h1>üêõ A Era do Software</h1>
            <p style="font-size: 1.3rem; color: var(--light-gray); max-width: 800px; margin: 1rem auto 0;">
                O Nascimento de uma Disciplina: Testando o Intang√≠vel
            </p>
        </div>
    </section>

    <!-- Introdu√ß√£o -->
    <section class="section">
        <div class="container">
            <div class="content-section fade-in-up">
                <h2>Um Novo Paradigma de Qualidade</h2>

                <p>
                    Durante mil√™nios, a humanidade aperfei√ßoou t√©cnicas para garantir a qualidade de objetos f√≠sicos:
                    edif√≠cios, ferramentas, produtos manufaturados. Voc√™ podia ver um defeito, toc√°-lo, medi-lo com
                    instrumentos f√≠sicos. Ent√£o, na segunda metade do s√©culo XX, surgiu algo radicalmente diferente:
                    <strong>software</strong>.
                </p>

                <p>
                    Software √© pura l√≥gica abstrata, instru√ß√µes que existem apenas como estados el√©tricos em circuitos.
                    Voc√™ n√£o pode segurar um bug de software nas m√£os, pesar uma falha l√≥gica ou medir visualmente
                    a qualidade de um algoritmo. Como aplicar s√©culos de sabedoria sobre qualidade a algo fundamentalmente
                    <em>intang√≠vel</em>?
                </p>

                <div class="quote-box">
                    <p>
                        "Software √© diferente de qualquer outro produto da engenharia humana. Um edif√≠cio mal
                        constru√≠do desmorona gradualmente. Software mal constru√≠do pode funcionar perfeitamente
                        por anos... at√© que uma combina√ß√£o espec√≠fica de condi√ß√µes o fa√ßa falhar catastroficamente."
                    </p>
                    <div class="quote-author">‚Äî O paradoxo da fragilidade invis√≠vel</div>
                </div>

                <p>
                    Esta se√ß√£o explora como pioneiros da computa√ß√£o inventaram, formalizaram e transformaram o
                    teste de software de um processo ad-hoc e assistem√°tico em uma <strong>disciplina rigorosa
                    e essencial</strong> da engenharia moderna.
                </p>
            </div>

            <!-- Grace Hopper e o Primeiro Bug -->
            <div class="content-section">
                <h2 id="hopper">ü¶ã "O Primeiro Bug Real"</h2>
                <h3>Grace Hopper e a Mariposa que Mudou a Linguagem</h3>

                <p>
                    Em 9 de setembro de 1947, no Computation Laboratory da Universidade de Harvard, algo incomum
                    aconteceu. O <strong>Harvard Mark II</strong>, um dos primeiros computadores eletromec√¢nicos,
                    estava apresentando comportamento err√°tico. A equipe de engenheiros, liderada pela Almirante
                    <strong>Grace Murray Hopper</strong>, investigou o problema.
                </p>

                <p>
                    Eles encontraram a causa: uma mariposa (moth) presa em um rel√© no Painel F do computador.
                    O inseto estava literalmente impedindo o circuito de fechar, causando falhas de c√°lculo.
                    Hopper e sua equipe removeram cuidadosamente a mariposa, colaram-na no livro de registros
                    (log book) e anotaram: <em>"First actual case of bug being found"</em> (Primeiro caso real
                    de bug sendo encontrado).
                </p>

                <div class="info-box">
                    <h3>Contexto Importante</h3>
                    <p>
                        O termo "bug" para descrever falhas t√©cnicas j√° existia antes de 1947. Thomas Edison
                        usou a palavra na d√©cada de 1870 para descrever problemas em inven√ß√µes. Mas o incidente
                        de Hopper popularizou definitivamente "bug" e "debugging" no contexto de computa√ß√£o,
                        tornando-os parte permanente do vocabul√°rio tecnol√≥gico.
                    </p>
                </div>

                <h3>Grace Hopper: Mais que uma Mariposa</h3>

                <p>
                    A hist√≥ria da mariposa, embora ic√¥nica, √© apenas uma pequena parte das contribui√ß√µes monumentais
                    de Grace Hopper para a computa√ß√£o e, indiretamente, para o teste de software:
                </p>

                <h4>Inven√ß√£o do Compilador (1952)</h4>
                <p>
                    Hopper desenvolveu o primeiro compilador, o <strong>A-0 System</strong>, que traduzia c√≥digo
                    simb√≥lico em linguagem de m√°quina. Isso foi revolucion√°rio: permitiu que programadores escrevessem
                    c√≥digo mais abstrato e compreens√≠vel, tornando programas mais <em>test√°veis</em> e <em>verific√°veis</em>.
                </p>

                <h4>COBOL e Legibilidade</h4>
                <p>
                    Hopper foi instrumental na cria√ß√£o da linguagem <strong>COBOL</strong> (Common Business-Oriented
                    Language) em 1959. COBOL priorizava legibilidade ‚Äî c√≥digo que se parecia com ingl√™s comum.
                    C√≥digo leg√≠vel √© c√≥digo test√°vel. Quando humanos podem entender facilmente o que o c√≥digo faz,
                    eles podem criar testes melhores e identificar erros l√≥gicos mais rapidamente.
                </p>

                <h4>Filosofia de Valida√ß√£o</h4>
                <p>
                    Hopper enfatizava a import√¢ncia de <strong>valida√ß√£o rigorosa</strong>. Ela acreditava que
                    programas deveriam ser verificados metodicamente, n√£o apenas "rodados e esperando que funcionem".
                    Esta mentalidade ajudou a estabelecer a cultura de teste formal na computa√ß√£o nascente.
                </p>

                <div class="quote-box">
                    <p>
                        "Uma nave n√£o afunda por causa do oceano ao seu redor; ela afunda por causa da √°gua
                        que entra nela. Da mesma forma, voc√™ n√£o pode deixar negatividade e problemas externos
                        afundarem seu esp√≠rito ‚Äî mas voc√™ tamb√©m n√£o pode deixar bugs internos afundarem seu c√≥digo."
                    </p>
                    <div class="quote-author">‚Äî Grace Hopper (adaptado)</div>
                </div>

                <h3>Legado: A Linguagem que Usamos</h3>

                <p>
                    Hoje, quando dizemos "vou debugar este c√≥digo", "encontrei um bug" ou "preciso ca√ßar este
                    bug", estamos usando linguagem que Grace Hopper ajudou a popularizar. Mais importante, a
                    √™nfase de Hopper em legibilidade, documenta√ß√£o e valida√ß√£o estabeleceu princ√≠pios que
                    permanecem fundamentais para qualidade de software moderna.
                </p>

                <ul style="font-size: 1.1rem; line-height: 1.8; margin: 1.5rem 0;">
                    <li><strong>C√≥digo leg√≠vel</strong> √© mais f√°cil de testar e debugar</li>
                    <li><strong>Abstra√ß√£o apropriada</strong> (compiladores, linguagens de alto n√≠vel) torna defeitos mais vis√≠veis</li>
                    <li><strong>Documenta√ß√£o rigorosa</strong> (como seus log books meticulosos) √© essencial para rastrear e resolver problemas</li>
                    <li><strong>Valida√ß√£o sistem√°tica</strong> deve ser parte integral do desenvolvimento, n√£o uma reflex√£o tardia</li>
                </ul>
            </div>

            <!-- Separa√ß√£o Formal: Teste vs Depura√ß√£o -->
            <div class="content-section">
                <h2 id="baker">üî¨ A Separa√ß√£o Formal: Teste vs. Depura√ß√£o</h2>
                <h3>Charles L. Baker e a Profissionaliza√ß√£o (1957)</h3>

                <p>
                    Nos primeiros dias da computa√ß√£o, as linhas entre escrever c√≥digo, test√°-lo e corrigi-lo
                    eram nebulosas. Programadores faziam tudo: escreviam, testavam informalmente, corrigiam bugs
                    conforme encontrados e repetiam. N√£o havia distin√ß√£o clara entre atividades ou objetivos.
                </p>

                <p>
                    Em 1957, <strong>Charles L. Baker</strong>, trabalhando no contexto de desenvolvimento de
                    sistemas cr√≠ticos, publicou argumentos que come√ßaram a formalizar a separa√ß√£o entre
                    <strong>teste</strong> e <strong>depura√ß√£o</strong> como atividades distintas com prop√≥sitos
                    diferentes.
                </p>

                <h3>Teste ‚â† Depura√ß√£o: Uma Distin√ß√£o Crucial</h3>

                <div class="card-grid" style="margin: 2rem 0;">
                    <div class="card">
                        <h3 style="color: var(--secondary-blue);">Teste (Testing)</h3>
                        <p><strong>Objetivo:</strong> Verificar se o software atende aos requisitos e especifica√ß√µes</p>
                        <p><strong>Quando:</strong> Atividade planejada, com casos de teste definidos antecipadamente</p>
                        <p><strong>Resultado desejado:</strong> Descobrir se existem defeitos (revela√ß√£o)</p>
                        <p><strong>Quem:</strong> Idealmente, algu√©m diferente do programador original</p>
                    </div>

                    <div class="card">
                        <h3 style="color: var(--secondary-blue);">Depura√ß√£o (Debugging)</h3>
                        <p><strong>Objetivo:</strong> Encontrar a causa raiz de um defeito conhecido e corrigi-lo</p>
                        <p><strong>Quando:</strong> Atividade reativa, ap√≥s um defeito ser descoberto</p>
                        <p><strong>Resultado desejado:</strong> Eliminar a causa do defeito (corre√ß√£o)</p>
                        <p><strong>Quem:</strong> Frequentemente o pr√≥prio programador, que entende o c√≥digo profundamente</p>
                    </div>
                </div>

                <h3>Por Que Esta Distin√ß√£o Importa?</h3>

                <h4>1. Mentalidades Diferentes</h4>
                <p>
                    <strong>Testar</strong> requer uma mentalidade de <em>ceticismo saud√°vel</em> ‚Äî assumir que
                    defeitos existem e cri√°-los para revel√°-los. <strong>Debugar</strong> requer uma mentalidade
                    de <em>detetive anal√≠tico</em> ‚Äî rastrear pistas, formular hip√≥teses e valid√°-las sistematicamente.
                </p>

                <h4>2. Habilidades Especializadas</h4>
                <p>
                    Ser excelente em escrever c√≥digo n√£o significa automaticamente ser excelente em test√°-lo.
                    Teste eficaz requer conhecimento de design de casos de teste, an√°lise de requisitos e
                    pensamento sobre condi√ß√µes extremas e edge cases.
                </p>

                <h4>3. Vi√©s do Programador</h4>
                <p>
                    Programadores t√™m vi√©s inconsciente ao testar seu pr√≥prio c√≥digo. Eles tendem a testar o que
                    <em>esperam que funcione</em>, n√£o o que <em>pode falhar</em>. Um testador independente traz
                    perspectiva fresca e objetividade.
                </p>

                <h4>4. Planejamento vs. Rea√ß√£o</h4>
                <p>
                    Teste √© uma atividade que deve ser <em>planejada antecipadamente</em>, com casos de teste
                    derivados de requisitos antes mesmo do c√≥digo ser escrito. Depura√ß√£o √© necessariamente
                    <em>reativa</em>, respondendo a defeitos j√° manifestados.
                </p>

                <div class="info-box">
                    <h3>O Ciclo Teste-Depura√ß√£o</h3>
                    <p>
                        Embora separados conceitualmente, teste e depura√ß√£o trabalham juntos em um ciclo:
                    </p>
                    <ol>
                        <li><strong>Teste</strong> executa casos de teste e revela um defeito</li>
                        <li><strong>Depura√ß√£o</strong> investiga, encontra a causa raiz e implementa uma corre√ß√£o</li>
                        <li><strong>Teste de regress√£o</strong> verifica se a corre√ß√£o funcionou e n√£o introduziu novos defeitos</li>
                        <li>Repete at√© que todos os testes passem</li>
                    </ol>
                </div>

                <h3>Impacto na Profissionaliza√ß√£o</h3>

                <p>
                    A distin√ß√£o formal entre teste e depura√ß√£o teve consequ√™ncias profundas:
                </p>

                <ul style="font-size: 1.1rem; line-height: 1.8; margin: 1.5rem 0;">
                    <li><strong>Especializa√ß√£o de pap√©is:</strong> Surgimento de testadores profissionais como carreira distinta</li>
                    <li><strong>Processos formalizados:</strong> Desenvolvimento de metodologias de teste (caixa-preta, caixa-branca, etc.)</li>
                    <li><strong>Ferramentas especializadas:</strong> Desenvolvimento de debuggers, frameworks de teste e ferramentas de an√°lise</li>
                    <li><strong>Educa√ß√£o formal:</strong> Curr√≠culos de ci√™ncia da computa√ß√£o come√ßam a incluir teste de software como t√≥pico espec√≠fico</li>
                </ul>

                <p>
                    Baker ajudou a estabelecer que <strong>teste n√£o √© uma atividade casual</strong> que "qualquer
                    programador pode fazer nas horas vagas". √â uma disciplina que requer conhecimento espec√≠fico,
                    planejamento cuidadoso e, idealmente, especialistas dedicados.
                </p>
            </div>

            <!-- Glenford Myers -->
            <div class="content-section">
                <h2 id="myers">üí° A Mentalidade Destrutiva de Myers</h2>
                <h3>"The Art of Software Testing" (1979)</h3>

                <p style="font-size: 1.2rem; font-weight: 500; color: var(--primary-blue);">
                    Se existe um √∫nico livro que revolucionou fundamentalmente como pensamos sobre teste de software,
                    √© "The Art of Software Testing" de Glenford J. Myers, publicado em 1979. Este livro n√£o apenas
                    compilou t√©cnicas de teste ‚Äî ele <strong>redefiniu o prop√≥sito e a psicologia do teste</strong>.
                </p>

                <h3>A Defini√ß√£o Revolucion√°ria</h3>

                <p>
                    Antes de Myers, o teste era frequentemente visto como uma atividade para demonstrar que o
                    software <em>funcionava</em>. Empresas executavam testes para "provar" que seus produtos
                    eram confi√°veis. Myers virou este conceito de cabe√ßa para baixo:
                </p>

                <div class="quote-box">
                    <p style="font-size: 1.3rem;">
                        <strong>"Testar √© o processo de executar um programa com a inten√ß√£o de encontrar erros."</strong>
                    </p>
                    <div class="quote-author">‚Äî Glenford J. Myers, 1979</div>
                </div>

                <p>
                    Esta defini√ß√£o simples √© profundamente radical. Vamos descompact√°-la:
                </p>

                <h4>1. "Inten√ß√£o de Encontrar Erros"</h4>
                <p>
                    Myers argumenta que um teste bem-sucedido √© aquele que <strong>encontra um defeito</strong>,
                    n√£o um que passa sem erros. Se voc√™ executa 100 testes e todos passam, voc√™ aprendeu pouco
                    ‚Äî talvez o software esteja correto, ou talvez seus testes sejam fracos. Mas se um teste falha,
                    voc√™ descobriu informa√ß√£o valiosa: h√° um problema que precisa ser corrigido.
                </p>

                <h4>2. Mudan√ßa de Mentalidade</h4>
                <p>
                    Testar para "provar que funciona" leva a testes otimistas e superficiais ‚Äî casos felizes,
                    entradas v√°lidas, condi√ß√µes normais. Testar para "encontrar erros" leva a testes pessimistas
                    e profundos ‚Äî edge cases, entradas inv√°lidas, condi√ß√µes extremas, combina√ß√µes inesperadas.
                </p>

                <div class="info-box">
                    <h3>O Paradoxo Psicol√≥gico do Teste</h3>
                    <p>
                        Myers identificou um problema psicol√≥gico: <strong>√© muito dif√≠cil testar rigorosamente
                        algo que voc√™ criou</strong>. Programadores investem ego e esfor√ßo em seu c√≥digo. Subconsciente,
                        eles querem que funcione. Esta motiva√ß√£o, embora compreens√≠vel, torna-os testadores ruins
                        de seu pr√≥prio trabalho ‚Äî eles evitam (inconscientemente) casos de teste que possam revelar
                        falhas que eles mesmos criaram.
                    </p>
                    <p>
                        <strong>Solu√ß√£o:</strong> Idealmente, testar deve ser feito por algu√©m diferente do autor
                        do c√≥digo, algu√©m sem investimento emocional em "provar que funciona" e que possa adotar
                        verdadeiramente a mentalidade destrutiva.
                    </p>
                </div>

                <h3>Princ√≠pios Fundamentais de Myers</h3>

                <p>
                    "The Art of Software Testing" estabeleceu princ√≠pios que permanecem relevantes d√©cadas depois:
                </p>

                <h4>Princ√≠pio 1: Impossibilidade de Teste Exaustivo</h4>
                <p>
                    √â imposs√≠vel testar um programa exaustivamente (todas as combina√ß√µes de entradas e estados).
                    Mesmo programas triviais t√™m espa√ßos de entrada astron√¥micos. Portanto, o teste deve ser
                    <strong>estrat√©gico</strong>, focando em √°reas de maior risco e usando t√©cnicas que maximizem
                    a probabilidade de encontrar defeitos.
                </p>

                <h4>Princ√≠pio 2: Presen√ßa de Defeitos</h4>
                <p>
                    Teste pode provar a <em>presen√ßa</em> de defeitos, mas nunca pode provar sua <em>aus√™ncia</em>.
                    Testes que passam n√£o garantem software sem bugs ‚Äî apenas que os bugs n√£o foram encontrados
                    pelos testes executados.
                </p>

                <h4>Princ√≠pio 3: Agrupamento de Defeitos (Pesticide Paradox)</h4>
                <p>
                    Defeitos tendem a se agrupar em m√≥dulos espec√≠ficos. Se voc√™ encontra um bug em uma √°rea do
                    c√≥digo, √© prov√°vel que haja mais bugs nessa mesma √°rea. <strong>Teste mais onde j√° encontrou
                    problemas</strong>.
                </p>

                <h4>Princ√≠pio 4: Paradoxo do Pesticida</h4>
                <p>
                    Se voc√™ executa os mesmos testes repetidamente, eventualmente eles param de encontrar novos bugs.
                    Os testes se tornam "imunes" ‚Äî como pragas desenvolvendo resist√™ncia a pesticidas. <strong>Casos
                    de teste devem ser revisados e atualizados regularmente</strong> para continuar eficazes.
                </p>

                <h3>T√©cnicas de Design de Casos de Teste</h3>

                <p>
                    Myers formalizou t√©cnicas espec√≠ficas para criar casos de teste eficazes:
                </p>

                <h4>Teste de Caixa-Preta (Black-Box Testing)</h4>
                <p>
                    Teste baseado em especifica√ß√µes, sem conhecimento da estrutura interna do c√≥digo. Foca em
                    <em>o que</em> o programa deve fazer, n√£o <em>como</em> ele faz.
                </p>
                <ul>
                    <li><strong>Particionamento de Equival√™ncia:</strong> Dividir entradas em classes que devem ser tratadas similarmente</li>
                    <li><strong>An√°lise de Valor Limite:</strong> Testar nos limites de parti√ß√µes (min, max, logo acima, logo abaixo)</li>
                    <li><strong>Tabela de Decis√£o:</strong> Mapear combina√ß√µes de condi√ß√µes e a√ß√µes resultantes</li>
                </ul>

                <h4>Teste de Caixa-Branca (White-Box Testing)</h4>
                <p>
                    Teste baseado na estrutura interna do c√≥digo. Foca em <em>como</em> o programa implementa
                    funcionalidades.
                </p>
                <ul>
                    <li><strong>Cobertura de Comandos:</strong> Executar cada linha de c√≥digo pelo menos uma vez</li>
                    <li><strong>Cobertura de Decis√µes:</strong> Executar cada branch (true/false) de condi√ß√µes</li>
                    <li><strong>Cobertura de Caminhos:</strong> Executar diferentes caminhos de execu√ß√£o poss√≠veis</li>
                </ul>

                <div class="quote-box">
                    <p>
                        "Um teste que n√£o encontra defeitos n√£o √© necessariamente um bom teste. Pode ser apenas
                        um teste fraco. O verdadeiro teste de um teste √© sua capacidade de revelar erros quando
                        eles existem."
                    </p>
                    <div class="quote-author">‚Äî Glenford J. Myers</div>
                </div>

                <h3>Impacto e Legado</h3>

                <p>
                    "The Art of Software Testing" se tornou um dos livros mais influentes da engenharia de software.
                    Seu impacto inclui:
                </p>

                <ul style="font-size: 1.1rem; line-height: 1.8; margin: 1.5rem 0;">
                    <li><strong>Profissionaliza√ß√£o do QA:</strong> Estabeleceu teste como uma disciplina t√©cnica s√©ria que requer expertise</li>
                    <li><strong>Educa√ß√£o formal:</strong> O livro se tornou leitura obrigat√≥ria em cursos de engenharia de software globalmente</li>
                    <li><strong>Certifica√ß√µes:</strong> Princ√≠pios de Myers fundamentam certifica√ß√µes como ISTQB (International Software Testing Qualifications Board)</li>
                    <li><strong>Cultura de qualidade:</strong> Influenciou organiza√ß√µes a valorizar testadores como contribuidores cr√≠ticos, n√£o apenas "verificadores"</li>
                </ul>

                <h3>Relev√¢ncia Moderna</h3>

                <p>
                    Mais de 40 anos ap√≥s sua publica√ß√£o, os princ√≠pios de Myers permanecem fundamentais:
                </p>

                <ul style="font-size: 1.1rem; line-height: 1.8; margin: 1.5rem 0;">
                    <li><strong>Testes unit√°rios (TDD):</strong> A mentalidade "escrever testes para falhar" ecoa a defini√ß√£o de Myers</li>
                    <li><strong>Code coverage:</strong> M√©tricas de cobertura s√£o descendentes diretas de t√©cnicas de caixa-branca</li>
                    <li><strong>Fuzzing e chaos engineering:</strong> Vers√µes modernas da mentalidade destrutiva ‚Äî atacar sistemas para encontrar fraquezas</li>
                    <li><strong>Bug bounties:</strong> Recompensar quem encontra bugs, n√£o quem "prova que funciona"</li>
                </ul>

                <p style="font-size: 1.2rem; margin-top: 2rem; font-weight: 500;">
                    Myers nos ensinou que <strong>testar n√£o √© validar otimismo, √© desafiar pressupostos</strong>.
                    O melhor testador n√£o √© quem encontra que tudo funciona ‚Äî √© quem encontra o que est√° quebrado
                    antes que os usu√°rios o fa√ßam.
                </p>
            </div>

            <!-- Conclus√£o da Se√ß√£o -->
            <div class="content-section">
                <h2>üñ•Ô∏è O Legado da Era do Software</h2>
                <h3>De Experimentos a Engenharia</h3>

                <p>
                    A era do software transformou teste de uma atividade informal em uma <strong>disciplina de
                    engenharia rigorosa</strong>. Tr√™s contribui√ß√µes foram fundamentais:
                </p>

                <div class="card-grid" style="margin: 2rem 0;">
                    <div class="card">
                        <h3 style="color: var(--bronze);">Grace Hopper</h3>
                        <p>Popularizou a linguagem (bug/debugging) e enfatizou legibilidade e valida√ß√£o sistem√°tica.</p>
                    </div>
                    <div class="card">
                        <h3 style="color: var(--bronze);">Charles Baker</h3>
                        <p>Formalizou a separa√ß√£o entre teste (revelar) e depura√ß√£o (corrigir) como disciplinas distintas.</p>
                    </div>
                    <div class="card">
                        <h3 style="color: var(--bronze);">Glenford Myers</h3>
                        <p>Redefiniu o prop√≥sito do teste: n√£o provar que funciona, mas encontrar onde falha.</p>
                    </div>
                    <div class="card">
                        <h3 style="color: var(--bronze);">Resultado</h3>
                        <p>Teste se torna uma profiss√£o reconhecida, com m√©todos, ferramentas e cultura pr√≥prios.</p>
                    </div>
                </div>

                <p>
                    Ao final da era cl√°ssica do software (d√©cadas de 1970-1990), os fundamentos estavam estabelecidos:
                </p>

                <ul style="font-size: 1.1rem; line-height: 1.8; margin: 1.5rem 0;">
                    <li>Teste √© uma atividade planejada e profissional, n√£o casual</li>
                    <li>Objetivo √© revelar defeitos, n√£o validar pressupostos</li>
                    <li>Requer mentalidade diferente (c√©tica/destrutiva) da programa√ß√£o</li>
                    <li>T√©cnicas formais (caixa-preta, caixa-branca) guiam design de testes</li>
                    <li>Independ√™ncia entre quem desenvolve e quem testa melhora qualidade</li>
                </ul>

                <div class="quote-box">
                    <p>
                        "A era do software nos ensinou que c√≥digo intang√≠vel requer valida√ß√£o tang√≠vel.
                        N√£o podemos ver bugs de software, mas podemos criar testes sistem√°ticos que os for√ßam
                        a se revelar."
                    </p>
                    <div class="quote-author">‚Äî S√≠ntese da era dos testes de software</div>
                </div>

                <p style="font-size: 1.2rem; margin-top: 2rem;">
                    Mas a evolu√ß√£o n√£o parou. O s√©culo XXI traria mudan√ßas ainda mais radicais: desenvolvimento
                    √°gil, integra√ß√£o cont√≠nua, DevOps e, finalmente, intelig√™ncia artificial. A jornada da
                    qualidade estava prestes a acelerar exponencialmente...
                </p>

                <div class="text-center mt-lg">
                    <a href="modern-future.html" class="btn btn-primary">
                        Pr√≥xima Era: O Futuro da Qualidade ‚Üí
                    </a>
                </div>
            </div>
        </div>
    </section>

    <!-- Footer -->
    <footer class="main-footer">
        <div class="container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>Navega√ß√£o</h3>
                    <ul class="footer-links">
                        <li><a href="../index.html">P√°gina Inicial</a></li>
                        <li><a href="ancient-roots.html">Ra√≠zes Antigas</a></li>
                        <li><a href="industrial-revolution.html">Revolu√ß√£o Industrial</a></li>
                        <li><a href="software-era.html">Era do Software</a></li>
                        <li><a href="modern-future.html">O Futuro</a></li>
                    </ul>
                </div>

                <div class="footer-section">
                    <h3>Recursos</h3>
                    <ul class="footer-links">
                        <li><a href="timeline.html">Linha do Tempo Completa</a></li>
                        <li><a href="pioneers.html">Pioneiros da Qualidade</a></li>
                    </ul>
                </div>

                <div class="footer-section">
                    <h3>Sobre Este Projeto</h3>
                    <p style="color: var(--light-gray); font-size: 0.95rem;">
                        Um site educacional dedicado a preservar e compartilhar a rica hist√≥ria
                        dos testes e garantia de qualidade, desde a antiguidade at√© a era moderna.
                    </p>
                </div>
            </div>

            <div class="footer-bottom">
                <p>&copy; 2025 A Jornada da Qualidade. Criado para fins educacionais.</p>
            </div>
        </div>
    </footer>

    <script src="../js/main.js"></script>
</body>
</html>
